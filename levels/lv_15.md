---
title: "Recovery"
tags: ["Inheritance", "ERC20"]
reference: https://ethernaut.openzeppelin.com/level/15
---

# Description

NaughtCoin is an ERC20 token and you're already holding all of them. The catch is that you'll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.

Things that might help

- The ERC20 Spec
- The OpenZeppelin codebase

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "openzeppelin-contracts-08/token/ERC20/ERC20.sol";

contract NaughtCoin is ERC20 {
    // string public constant name = 'NaughtCoin';
    // string public constant symbol = '0x0';
    // uint public constant decimals = 18;
    uint256 public timeLock = block.timestamp + 10 * 365 days;
    uint256 public INITIAL_SUPPLY;
    address public player;

    constructor(address _player) ERC20("NaughtCoin", "0x0") {
        player = _player;
        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));
        // _totalSupply = INITIAL_SUPPLY;
        // _balances[player] = INITIAL_SUPPLY;
        _mint(player, INITIAL_SUPPLY);
        emit Transfer(address(0), player, INITIAL_SUPPLY);
    }

    function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {
        super.transfer(_to, _value);
    }

    // Prevent the initial owner from transferring tokens until the timelock has passed
    modifier lockTokens() {
        if (msg.sender == player) {
            require(block.timestamp > timeLock);
            _;
        } else {
            _;
        }
    }
}
```

# Solution

1. NaughtCoin is child contract of ERC20

2. only `transfer` function is overrided with `lockTokens` modifier

3. but ERC20 also support `transferFrom` function

ref: https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md#transferfrom

4. check ERC20 source code

We need to **approve** the spender to transfer our token first.

```sol
function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
    address spender = _msgSender();
    _spendAllowance(from, spender, value);
    _transfer(from, to, value);
    return true;
}
```

5. deploy `NaughtCoinSpender` contract

```sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface INaughtCoin {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);
}

contract NaughtCoinSpender {

    function pwn(address _coin, uint256 _value) external {
        INaughtCoin(_coin).transferFrom(msg.sender, address(this), _value);
    }

}
```

6. approve spender to transfer our tokens

```
cast send 0x49F659554835908eF97170500cd62f7AA8c526F9 "approve(address,uint256)" 0xa9Dd28C03518CE04d87c812CfD58273d841A9F7F 1000000000000000000000000 --rpc-url $BASE_SEPOLIA_RPC --private-key 
```

7. call `pwn()` function

```
cast send 0xa9Dd28C03518CE04d87c812CfD58273d841A9F7F "pwn(address,uint256)"  0x49F659554835908eF97170500cd62f7AA8c526F9 1000000000000000000000000 --rpc-url $BASE_SEPOLIA_RPC --private-key
```

8. check player balance

```
await contract.balanceOf(player)
(2) [0, empty]
```
